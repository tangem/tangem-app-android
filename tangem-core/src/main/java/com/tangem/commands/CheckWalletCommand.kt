package com.tangem.commands

import com.tangem.common.CardEnvironment
import com.tangem.common.apdu.CommandApdu
import com.tangem.common.apdu.Instruction
import com.tangem.common.apdu.ResponseApdu
import com.tangem.common.tlv.TlvBuilder
import com.tangem.common.tlv.TlvMapper
import com.tangem.common.tlv.TlvTag
import com.tangem.crypto.CryptoUtils
import com.tangem.tasks.TaskError

/**
 * Deserialized response from the Tangem card after [CheckWalletCommand].
 *
 * @property cardId Unique Tangem card ID number
 * @property salt Random salt generated by the card.
 * @property walletSignature Challenge and salt signed with the wallet private key.
 */
class CheckWalletResponse(
        val cardId: String,
        val salt: ByteArray,
        val walletSignature: ByteArray
) : CommandResponse {

    fun verify(curve: EllipticCurve, publicKey: ByteArray, challenge: ByteArray): Boolean {
        return CryptoUtils.verify(
                publicKey,
                challenge + salt,
                walletSignature,
                curve)
    }
}

/**
 * This command proves that the wallet private key from the card corresponds to the wallet public key.
 * Standard challenge/response scheme is used.
 *
 * @property pin1 Hashed user’s pin 1 code to access the card. Default unhashed value: ‘000000’.
 * @property cardId Unique Tangem card ID number
 * @property challenge Random challenge generated by application
 */
class CheckWalletCommand : CommandSerializer<CheckWalletResponse>() {

    val challenge = CryptoUtils.generateRandomBytes(16)

    override fun serialize(cardEnvironment: CardEnvironment): CommandApdu {
        val tlvBuilder = TlvBuilder()
        tlvBuilder.append(TlvTag.Pin, cardEnvironment.pin1)
        tlvBuilder.append(TlvTag.CardId, cardEnvironment.cardId)
        tlvBuilder.append(TlvTag.Challenge, challenge)
        return CommandApdu(
                Instruction.CheckWallet, tlvBuilder.serialize(),
                cardEnvironment.encryptionMode, cardEnvironment.encryptionKey
        )
    }

    override fun deserialize(cardEnvironment: CardEnvironment, responseApdu: ResponseApdu): CheckWalletResponse? {
        val tlvData = responseApdu.getTlvData(cardEnvironment.encryptionKey) ?: return null

        return try {
            val mapper = TlvMapper(tlvData)
            CheckWalletResponse(
                    cardId = mapper.map(TlvTag.CardId),
                    salt = mapper.map(TlvTag.Salt),
                    walletSignature = mapper.map(TlvTag.Signature)
            )
        } catch (exception: Exception) {
            throw TaskError.SerializeCommandError()
        }
    }
}