// Code generated by moshi-kotlin-codegen. Do not edit.
@file:Suppress("DEPRECATION", "unused", "UNUSED_PARAMETER", "ClassName", "REDUNDANT_PROJECTION",
    "RedundantExplicitType", "LocalVariableName", "RedundantVisibilityModifier",
    "PLATFORM_CLASS_MAPPED_TO_KOTLIN", "IMPLICIT_NOTHING_TYPE_ARGUMENT_IN_RETURN_POSITION")

package com.tangem.domain.models.scan

import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.JsonReader
import com.squareup.moshi.JsonWriter
import com.squareup.moshi.Moshi
import com.squareup.moshi.Types
import com.squareup.moshi.`internal`.Util
import com.tangem.common.card.CardWallet
import com.tangem.common.card.EllipticCurve
import com.tangem.crypto.hdWallet.DerivationPath
import com.tangem.crypto.hdWallet.bip32.ExtendedPublicKey
import java.lang.NullPointerException
import java.lang.reflect.Constructor
import kotlin.Boolean
import kotlin.ByteArray
import kotlin.Int
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlin.collections.Map
import kotlin.collections.emptySet
import kotlin.jvm.Volatile
import kotlin.text.buildString

public class CardDTO_WalletJsonAdapter(
  moshi: Moshi,
) : JsonAdapter<CardDTO.Wallet>() {
  private val options: JsonReader.Options = JsonReader.Options.of("publicKey", "chainCode", "curve",
      "settings", "totalSignedHashes", "remainingSignatures", "index", "hasBackup", "derivedKeys",
      "extendedPublicKey", "isImported")

  private val byteArrayAdapter: JsonAdapter<ByteArray> = moshi.adapter(ByteArray::class.java,
      emptySet(), "publicKey")

  private val nullableByteArrayAdapter: JsonAdapter<ByteArray?> =
      moshi.adapter(ByteArray::class.java, emptySet(), "chainCode")

  private val ellipticCurveAdapter: JsonAdapter<EllipticCurve> =
      moshi.adapter(EllipticCurve::class.java, emptySet(), "curve")

  private val settingsAdapter: JsonAdapter<CardWallet.Settings> =
      moshi.adapter(CardWallet.Settings::class.java, emptySet(), "settings")

  private val nullableIntAdapter: JsonAdapter<Int?> = moshi.adapter(Int::class.javaObjectType,
      emptySet(), "totalSignedHashes")

  private val intAdapter: JsonAdapter<Int> = moshi.adapter(Int::class.java, emptySet(), "index")

  private val booleanAdapter: JsonAdapter<Boolean> = moshi.adapter(Boolean::class.java, emptySet(),
      "hasBackup")

  private val mapOfDerivationPathExtendedPublicKeyAdapter:
      JsonAdapter<Map<DerivationPath, ExtendedPublicKey>> =
      moshi.adapter(Types.newParameterizedType(Map::class.java, DerivationPath::class.java,
      ExtendedPublicKey::class.java), emptySet(), "derivedKeys")

  private val nullableExtendedPublicKeyAdapter: JsonAdapter<ExtendedPublicKey?> =
      moshi.adapter(ExtendedPublicKey::class.java, emptySet(), "extendedPublicKey")

  @Volatile
  private var constructorRef: Constructor<CardDTO.Wallet>? = null

  public override fun toString(): String = buildString(36) {
      append("GeneratedJsonAdapter(").append("CardDTO.Wallet").append(')') }

  public override fun fromJson(reader: JsonReader): CardDTO.Wallet {
    var publicKey: ByteArray? = null
    var chainCode: ByteArray? = null
    var curve: EllipticCurve? = null
    var settings: CardWallet.Settings? = null
    var totalSignedHashes: Int? = null
    var remainingSignatures: Int? = null
    var index: Int? = null
    var hasBackup: Boolean? = null
    var derivedKeys: Map<DerivationPath, ExtendedPublicKey>? = null
    var extendedPublicKey: ExtendedPublicKey? = null
    var isImported: Boolean? = false
    var mask0 = -1
    reader.beginObject()
    while (reader.hasNext()) {
      when (reader.selectName(options)) {
        0 -> publicKey = byteArrayAdapter.fromJson(reader) ?: throw Util.unexpectedNull("publicKey",
            "publicKey", reader)
        1 -> chainCode = nullableByteArrayAdapter.fromJson(reader)
        2 -> curve = ellipticCurveAdapter.fromJson(reader) ?: throw Util.unexpectedNull("curve",
            "curve", reader)
        3 -> settings = settingsAdapter.fromJson(reader) ?: throw Util.unexpectedNull("settings",
            "settings", reader)
        4 -> totalSignedHashes = nullableIntAdapter.fromJson(reader)
        5 -> remainingSignatures = nullableIntAdapter.fromJson(reader)
        6 -> index = intAdapter.fromJson(reader) ?: throw Util.unexpectedNull("index", "index",
            reader)
        7 -> hasBackup = booleanAdapter.fromJson(reader) ?: throw Util.unexpectedNull("hasBackup",
            "hasBackup", reader)
        8 -> derivedKeys = mapOfDerivationPathExtendedPublicKeyAdapter.fromJson(reader) ?:
            throw Util.unexpectedNull("derivedKeys", "derivedKeys", reader)
        9 -> extendedPublicKey = nullableExtendedPublicKeyAdapter.fromJson(reader)
        10 -> {
          isImported = booleanAdapter.fromJson(reader) ?: throw Util.unexpectedNull("isImported",
              "isImported", reader)
          // $mask = $mask and (1 shl 10).inv()
          mask0 = mask0 and 0xfffffbff.toInt()
        }
        -1 -> {
          // Unknown name, skip it.
          reader.skipName()
          reader.skipValue()
        }
      }
    }
    reader.endObject()
    if (mask0 == 0xfffffbff.toInt()) {
      // All parameters with defaults are set, invoke the constructor directly
      return  CardDTO.Wallet(
          publicKey = publicKey ?: throw Util.missingProperty("publicKey", "publicKey", reader),
          chainCode = chainCode,
          curve = curve ?: throw Util.missingProperty("curve", "curve", reader),
          settings = settings ?: throw Util.missingProperty("settings", "settings", reader),
          totalSignedHashes = totalSignedHashes,
          remainingSignatures = remainingSignatures,
          index = index ?: throw Util.missingProperty("index", "index", reader),
          hasBackup = hasBackup ?: throw Util.missingProperty("hasBackup", "hasBackup", reader),
          derivedKeys = derivedKeys ?: throw Util.missingProperty("derivedKeys", "derivedKeys",
              reader),
          extendedPublicKey = extendedPublicKey,
          isImported = isImported as Boolean
      )
    } else {
      // Reflectively invoke the synthetic defaults constructor
      @Suppress("UNCHECKED_CAST")
      val localConstructor: Constructor<CardDTO.Wallet> = this.constructorRef ?:
          CardDTO.Wallet::class.java.getDeclaredConstructor(ByteArray::class.java,
          ByteArray::class.java, EllipticCurve::class.java, CardWallet.Settings::class.java,
          Int::class.javaObjectType, Int::class.javaObjectType, Int::class.javaPrimitiveType,
          Boolean::class.javaPrimitiveType, Map::class.java, ExtendedPublicKey::class.java,
          Boolean::class.javaPrimitiveType, Int::class.javaPrimitiveType,
          Util.DEFAULT_CONSTRUCTOR_MARKER).also { this.constructorRef = it }
      return localConstructor.newInstance(
          publicKey ?: throw Util.missingProperty("publicKey", "publicKey", reader),
          chainCode,
          curve ?: throw Util.missingProperty("curve", "curve", reader),
          settings ?: throw Util.missingProperty("settings", "settings", reader),
          totalSignedHashes,
          remainingSignatures,
          index ?: throw Util.missingProperty("index", "index", reader),
          hasBackup ?: throw Util.missingProperty("hasBackup", "hasBackup", reader),
          derivedKeys ?: throw Util.missingProperty("derivedKeys", "derivedKeys", reader),
          extendedPublicKey,
          isImported,
          mask0,
          /* DefaultConstructorMarker */ null
      )
    }
  }

  public override fun toJson(writer: JsonWriter, value_: CardDTO.Wallet?): Unit {
    if (value_ == null) {
      throw NullPointerException("value_ was null! Wrap in .nullSafe() to write nullable values.")
    }
    writer.beginObject()
    writer.name("publicKey")
    byteArrayAdapter.toJson(writer, value_.publicKey)
    writer.name("chainCode")
    nullableByteArrayAdapter.toJson(writer, value_.chainCode)
    writer.name("curve")
    ellipticCurveAdapter.toJson(writer, value_.curve)
    writer.name("settings")
    settingsAdapter.toJson(writer, value_.settings)
    writer.name("totalSignedHashes")
    nullableIntAdapter.toJson(writer, value_.totalSignedHashes)
    writer.name("remainingSignatures")
    nullableIntAdapter.toJson(writer, value_.remainingSignatures)
    writer.name("index")
    intAdapter.toJson(writer, value_.index)
    writer.name("hasBackup")
    booleanAdapter.toJson(writer, value_.hasBackup)
    writer.name("derivedKeys")
    mapOfDerivationPathExtendedPublicKeyAdapter.toJson(writer, value_.derivedKeys)
    writer.name("extendedPublicKey")
    nullableExtendedPublicKeyAdapter.toJson(writer, value_.extendedPublicKey)
    writer.name("isImported")
    booleanAdapter.toJson(writer, value_.isImported)
    writer.endObject()
  }
}